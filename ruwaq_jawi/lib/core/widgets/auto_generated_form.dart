import 'package:flutter/material.dart';
import 'package:flutter/services.dart';
import 'package:hugeicons/hugeicons.dart';
import 'package:shadcn_ui/shadcn_ui.dart';
import '../services/simple_database_schema_analyzer.dart' show TableSchema, DatabaseField, FormFieldType, ValidationRule;
import '../theme/app_theme.dart';

/// Configuration for customizing specific form fields
class FormFieldConfig {
  final String? label;
  final String? placeholder;
  final Widget? customWidget;
  final List<ValidationRule> additionalValidations;
  final bool hidden;
  final Map<String, dynamic>? dropdownOptions;

  const FormFieldConfig({
    this.label,
    this.placeholder,
    this.customWidget,
    this.additionalValidations = const [],
    this.hidden = false,
    this.dropdownOptions,
  });
}

/// Auto-generated form widget based on database schema
class AutoGeneratedForm extends StatefulWidget {
  final TableSchema schema;
  final Map<String, dynamic>? initialData;
  final Map<String, FormFieldConfig>? fieldConfigs;
  final List<String>? hiddenFields;
  final Function(Map<String, dynamic>)? onSave;
  final VoidCallback? onCancel;
  final bool isLoading;

  const AutoGeneratedForm({
    super.key,
    required this.schema,
    this.initialData,
    this.fieldConfigs,
    this.hiddenFields,
    this.onSave,
    this.onCancel,
    this.isLoading = false,
  });

  @override
  State<AutoGeneratedForm> createState() => _AutoGeneratedFormState();
}

class _AutoGeneratedFormState extends State<AutoGeneratedForm> {
  final _formKey = GlobalKey<FormState>();
  final Map<String, TextEditingController> _controllers = {};
  final Map<String, dynamic> _formData = {};
  final Map<String, List<Map<String, dynamic>>> _foreignKeyData = {};
  final Map<String, String?> _fieldErrors = {};

  @override
  void initState() {
    super.initState();
    _initializeForm();
    _loadForeignKeyData();
  }

  @override
  void dispose() {
    for (final controller in _controllers.values) {
      controller.dispose();
    }
    super.dispose();
  }

  void _initializeForm() {
    for (final field in widget.schema.formFields) {
      if (_isFieldHidden(field.name)) continue;

      // Initialize controllers for text fields
      if (_needsController(field.formFieldType)) {
        final initialValue = widget.initialData?[field.name]?.toString() ?? '';
        _controllers[field.name] = TextEditingController(text: initialValue);
      }

      // Initialize form data
      _formData[field.name] = widget.initialData?[field.name];
    }
  }

  bool _isFieldHidden(String fieldName) {
    final config = widget.fieldConfigs?[fieldName];
    if (config?.hidden == true) return true;
    if (widget.hiddenFields?.contains(fieldName) == true) return true;
    return false;
  }

  bool _needsController(FormFieldType type) {
    return [
      FormFieldType.text,
      FormFieldType.textArea,
      FormFieldType.number,
      FormFieldType.decimal,
    ].contains(type);
  }

  Future<void> _loadForeignKeyData() async {
    for (final field in widget.schema.foreignKeyFields) {
      if (_isFieldHidden(field.name)) continue;

      try {
        // For now, return empty data for foreign keys
        final data = <Map<String, dynamic>>[];
        setState(() {
          _foreignKeyData[field.name] = data;
        });
      } catch (e) {
        // Debug logging removed
      }
    }
  }

  @override
  Widget build(BuildContext context) {
    return Form(
      key: _formKey,
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.stretch,
        children: [
          // Form title
          Container(
            padding: const EdgeInsets.all(24),
            decoration: BoxDecoration(
              color: AppTheme.surfaceColor,
              borderRadius: const BorderRadius.only(
                topLeft: Radius.circular(16),
                topRight: Radius.circular(16),
              ),
            ),
            child: Row(
              children: [
                Icon(
                  HugeIcons.strokeRoundedEdit02,
                  color: AppTheme.primaryColor,
                  size: 24,
                ),
                const SizedBox(width: 12),
                Text(
                  widget.initialData != null
                      ? 'Edit ${_formatTableName(widget.schema.name)}'
                      : 'Add New ${_formatTableName(widget.schema.name)}',
                  style: const TextStyle(
                    fontSize: 20,
                    fontWeight: FontWeight.w600,
                    color: AppTheme.textPrimaryColor,
                  ),
                ),
              ],
            ),
          ),

          // Form fields
          Expanded(
            child: SingleChildScrollView(
              padding: const EdgeInsets.all(24),
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.stretch,
                children: [
                  ...widget.schema.formFields
                      .where((field) => !_isFieldHidden(field.name))
                      .map((field) => _buildFormField(field)),
                ],
              ),
            ),
          ),

          // Action buttons
          Container(
            padding: const EdgeInsets.all(24),
            decoration: BoxDecoration(
              color: AppTheme.surfaceColor,
              borderRadius: const BorderRadius.only(
                bottomLeft: Radius.circular(16),
                bottomRight: Radius.circular(16),
              ),
              border: Border(
                top: BorderSide(color: AppTheme.borderColor),
              ),
            ),
            child: Row(
              children: [
                Expanded(
                  child: ShadButton.outline(
                    onPressed: widget.isLoading ? null : widget.onCancel,
                    child: const Text('Cancel'),
                  ),
                ),
                const SizedBox(width: 12),
                Expanded(
                  flex: 2,
                  child: ShadButton(
                    onPressed: widget.isLoading ? null : _onSave,
                    child: widget.isLoading
                        ? const SizedBox(
                            width: 20,
                            height: 20,
                            child: CircularProgressIndicator(strokeWidth: 2),
                          )
                        : const Text('Save'),
                  ),
                ),
              ],
            ),
          ),
        ],
      ),
    );
  }

  Widget _buildFormField(DatabaseField field) {
    final config = widget.fieldConfigs?[field.name];

    // Use custom widget if provided
    if (config?.customWidget != null) {
      return Padding(
        padding: const EdgeInsets.only(bottom: 20),
        child: config!.customWidget!,
      );
    }

    return Padding(
      padding: const EdgeInsets.only(bottom: 20),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          // Field label
          Text(
            config?.label ?? _formatFieldName(field.name),
            style: const TextStyle(
              fontSize: 14,
              fontWeight: FontWeight.w500,
              color: AppTheme.textPrimaryColor,
            ),
          ),
          const SizedBox(height: 8),

          // Field input
          _buildFieldInput(field, config),

          // Field help text
          if (field.comment != null) ...[
            const SizedBox(height: 4),
            Text(
              field.comment!,
              style: TextStyle(
                fontSize: 12,
                color: AppTheme.textSecondaryColor,
              ),
            ),
          ],
        ],
      ),
    );
  }

  Widget _buildFieldInput(DatabaseField field, FormFieldConfig? config) {
    switch (field.formFieldType) {
      case FormFieldType.text:
        return _buildTextField(field, config);

      case FormFieldType.textArea:
        return _buildTextArea(field, config);

      case FormFieldType.number:
      case FormFieldType.decimal:
        return _buildNumberField(field, config);

      case FormFieldType.switch_:
        return _buildSwitchField(field, config);

      case FormFieldType.dropdown:
        return _buildDropdownField(field, config);

      case FormFieldType.date:
        return _buildDateField(field, config);

      case FormFieldType.datetime:
        return _buildDateTimeField(field, config);

      default:
        return _buildTextField(field, config);
    }
  }

  Widget _buildTextField(DatabaseField field, FormFieldConfig? config) {
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        ShadInput(
          controller: _controllers[field.name],
          placeholder: Text(config?.placeholder ?? 'Enter ${_formatFieldName(field.name)}'),
          onChanged: (value) {
            _formData[field.name] = value;
            // Trigger validation
            final error = _validateField(field, value, config);
            setState(() {
              _fieldErrors[field.name] = error;
            });
          },
        ),
        if (_fieldErrors[field.name] != null)
          Padding(
            padding: const EdgeInsets.only(top: 4),
            child: Text(
              _fieldErrors[field.name]!,
              style: const TextStyle(
                color: Colors.red,
                fontSize: 12,
              ),
            ),
          ),
      ],
    );
  }

  Widget _buildTextArea(DatabaseField field, FormFieldConfig? config) {
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        ShadInput(
          controller: _controllers[field.name],
          placeholder: Text(config?.placeholder ?? 'Enter ${_formatFieldName(field.name)}'),
          maxLines: 4,
          onChanged: (value) {
            _formData[field.name] = value;
            // Trigger validation
            final error = _validateField(field, value, config);
            setState(() {
              _fieldErrors[field.name] = error;
            });
          },
        ),
        if (_fieldErrors[field.name] != null)
          Padding(
            padding: const EdgeInsets.only(top: 4),
            child: Text(
              _fieldErrors[field.name]!,
              style: const TextStyle(
                color: Colors.red,
                fontSize: 12,
              ),
            ),
          ),
      ],
    );
  }

  Widget _buildNumberField(DatabaseField field, FormFieldConfig? config) {
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        ShadInput(
          controller: _controllers[field.name],
          placeholder: Text(config?.placeholder ?? 'Enter ${_formatFieldName(field.name)}'),
          keyboardType: field.formFieldType == FormFieldType.decimal
              ? const TextInputType.numberWithOptions(decimal: true)
              : TextInputType.number,
          inputFormatters: field.formFieldType == FormFieldType.decimal
              ? [FilteringTextInputFormatter.allow(RegExp(r'^\d+\.?\d{0,2}'))]
              : [FilteringTextInputFormatter.digitsOnly],
          onChanged: (value) {
            if (field.formFieldType == FormFieldType.decimal) {
              _formData[field.name] = double.tryParse(value);
            } else {
              _formData[field.name] = int.tryParse(value);
            }
            // Trigger validation
            final error = _validateField(field, value, config);
            setState(() {
              _fieldErrors[field.name] = error;
            });
          },
        ),
        if (_fieldErrors[field.name] != null)
          Padding(
            padding: const EdgeInsets.only(top: 4),
            child: Text(
              _fieldErrors[field.name]!,
              style: const TextStyle(
                color: Colors.red,
                fontSize: 12,
              ),
            ),
          ),
      ],
    );
  }

  Widget _buildSwitchField(DatabaseField field, FormFieldConfig? config) {
    return Row(
      children: [
        ShadSwitch(
          value: _formData[field.name] ?? false,
          onChanged: (value) {
            setState(() {
              _formData[field.name] = value;
            });
          },
        ),
        const SizedBox(width: 12),
        Text(
          config?.placeholder ?? _formatFieldName(field.name),
          style: const TextStyle(
            fontSize: 14,
            color: AppTheme.textPrimaryColor,
          ),
        ),
      ],
    );
  }

  Widget _buildDropdownField(DatabaseField field, FormFieldConfig? config) {
    List<Map<String, dynamic>> options = [];

    // Use custom dropdown options if provided
    if (config?.dropdownOptions != null) {
      // Convert config options to standard format
      options = (config!.dropdownOptions!['items'] as List?)
              ?.cast<Map<String, dynamic>>() ?? [];
    } else if (field.enumValues != null) {
      // Use enum values
      options = field.enumValues!.map((value) => {
        'id': value,
        'name': _formatFieldName(value),
      }).toList();
    } else if (field.foreignKeyTable != null) {
      // Use foreign key data
      options = _foreignKeyData[field.name] ?? [];
    }

    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        ShadSelect<String>(
          placeholder: Text(config?.placeholder ?? 'Select ${_formatFieldName(field.name)}'),
          initialValue: _formData[field.name]?.toString(),
          selectedOptionBuilder: (context, value) => Text(
            options.firstWhere((opt) => opt['id'].toString() == value,
              orElse: () => {'name': value})['name'].toString()
          ),
          onChanged: (value) {
            setState(() {
              _formData[field.name] = value;
              // Trigger validation
              final error = _validateField(field, value, config);
              _fieldErrors[field.name] = error;
            });
          },
          options: options.map((option) =>
            ShadOption(
              value: option['id'].toString(),
              child: Text(option['name'].toString()),
            )
          ).toList(),
        ),
        if (_fieldErrors[field.name] != null)
          Padding(
            padding: const EdgeInsets.only(top: 4),
            child: Text(
              _fieldErrors[field.name]!,
              style: const TextStyle(
                color: Colors.red,
                fontSize: 12,
              ),
            ),
          ),
      ],
    );
  }

  Widget _buildDateField(DatabaseField field, FormFieldConfig? config) {
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        ShadInput(
          controller: _controllers[field.name],
          placeholder: Text(config?.placeholder ?? 'YYYY-MM-DD'),
          onChanged: (value) {
            _formData[field.name] = value;
            // Trigger validation
            final error = _validateField(field, value, config);
            setState(() {
              _fieldErrors[field.name] = error;
            });
          },
        ),
        if (_fieldErrors[field.name] != null)
          Padding(
            padding: const EdgeInsets.only(top: 4),
            child: Text(
              _fieldErrors[field.name]!,
              style: const TextStyle(
                color: Colors.red,
                fontSize: 12,
              ),
            ),
          ),
      ],
    );
  }

  Widget _buildDateTimeField(DatabaseField field, FormFieldConfig? config) {
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        ShadInput(
          controller: _controllers[field.name],
          placeholder: Text(config?.placeholder ?? 'YYYY-MM-DD HH:MM:SS'),
          onChanged: (value) {
            _formData[field.name] = value;
            // Trigger validation
            final error = _validateField(field, value, config);
            setState(() {
              _fieldErrors[field.name] = error;
            });
          },
        ),
        if (_fieldErrors[field.name] != null)
          Padding(
            padding: const EdgeInsets.only(top: 4),
            child: Text(
              _fieldErrors[field.name]!,
              style: const TextStyle(
                color: Colors.red,
                fontSize: 12,
              ),
            ),
          ),
      ],
    );
  }

  String? _validateField(DatabaseField field, String? value, FormFieldConfig? config) {
    final rules = [
      ...field.validationRules,
      ...config?.additionalValidations ?? [],
    ];

    for (final rule in rules) {
      switch (rule) {
        case ValidationRule.required:
          if (value == null || value.trim().isEmpty) {
            return '${_formatFieldName(field.name)} is required';
          }
          break;

        case ValidationRule.email:
          if (value != null && value.isNotEmpty) {
            final emailRegex = RegExp(r'^[\w-\.]+@([\w-]+\.)+[\w-]{2,4}$');
            if (!emailRegex.hasMatch(value)) {
              return 'Please enter a valid email address';
            }
          }
          break;

        case ValidationRule.url:
          if (value != null && value.isNotEmpty) {
            final urlRegex = RegExp(r'^https?:\/\/.+');
            if (!urlRegex.hasMatch(value)) {
              return 'Please enter a valid URL';
            }
          }
          break;

        case ValidationRule.integer:
          if (value != null && value.isNotEmpty) {
            if (int.tryParse(value) == null) {
              return 'Please enter a valid integer';
            }
          }
          break;

        case ValidationRule.decimal:
          if (value != null && value.isNotEmpty) {
            if (double.tryParse(value) == null) {
              return 'Please enter a valid number';
            }
          }
          break;

        case ValidationRule.positive:
          if (value != null && value.isNotEmpty) {
            final num = double.tryParse(value);
            if (num != null && num <= 0) {
              return '${_formatFieldName(field.name)} must be positive';
            }
          }
          break;

        case ValidationRule.nonNegative:
          if (value != null && value.isNotEmpty) {
            final num = double.tryParse(value);
            if (num != null && num < 0) {
              return '${_formatFieldName(field.name)} cannot be negative';
            }
          }
          break;

        default:
          break;
      }
    }

    return null;
  }

  void _onSave() {
    if (_formKey.currentState?.validate() == true) {
      // Collect all form data
      final data = Map<String, dynamic>.from(_formData);

      // Update with controller values
      for (final entry in _controllers.entries) {
        if (entry.value.text.isNotEmpty) {
          data[entry.key] = entry.value.text;
        }
      }

      widget.onSave?.call(data);
    }
  }

  String _formatTableName(String tableName) {
    return tableName
        .split('_')
        .map((word) => word.substring(0, 1).toUpperCase() + word.substring(1))
        .join(' ');
  }

  String _formatFieldName(String fieldName) {
    return fieldName
        .replaceAll('_', ' ')
        .split(' ')
        .map((word) => word.substring(0, 1).toUpperCase() + word.substring(1))
        .join(' ');
  }
}